<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于双指针的滑动窗口方法在数组问题中的应用</title>
    <link href="/2020/07/22/%E5%9F%BA%E4%BA%8E%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%96%B9%E6%B3%95%E5%9C%A8%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/07/22/%E5%9F%BA%E4%BA%8E%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%96%B9%E6%B3%95%E5%9C%A8%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LeetCode中有道题：取一个字符串中不含重复字符的最长子串的长度。<br>原题是：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p><blockquote><p>Given a string, find the length of the longest substring without repeating characters.</p></blockquote><p> 最直接的想法是暴力法穷举所有的子串，取其中不包含重复字符的最长的一个。</p><pre><code class="hljs java">result=<span class="hljs-number">0</span><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to n-<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> j=i+<span class="hljs-number">1</span> to n        s=substring(i,j)        <span class="hljs-keyword">if</span>(s.allunique() and s.length&gt;result)            result=s.length<span class="hljs-keyword">return</span> result</code></pre><p>其中判断一个字符串是否包含不重复的字符，借助集合的数据结构，至少需要一趟比较。所以，暴力穷举的时间复杂度将达到</p><p>O(n^3)。当需要处理的字符创较长时，LeetCode平台将拒绝接受。</p><p>考虑对暴力方法进行优化：当substring(i,j)含有重复字符时，那么substring(i,k) k[i+1,n] 一定会包含重复字符，不用再进行判断即可，此时需要将头部指针i向后移动一个单位继续判断即可；若substring(i,j)不含有重复字符，则将尾部指针j向后移动一个单位继续判断。i和j之间则形成了一个滑动窗口。所以基于双指针i和j形成如下优化算法：</p><pre><code class="hljs java">i=<span class="hljs-number">0</span>j=<span class="hljs-number">1</span>result=<span class="hljs-number">0</span><span class="hljs-keyword">while</span>(i&lt;n and j&lt;n)    <span class="hljs-keyword">while</span>(j&lt;<span class="hljs-function">n and <span class="hljs-title">substring</span><span class="hljs-params">(i,j)</span>.<span class="hljs-title">contains</span><span class="hljs-params">(string.chatAt(j)</span>))</span><span class="hljs-function">        j++</span><span class="hljs-function">    result</span>=result&gt;j-i?result:j-i    i++<span class="hljs-keyword">return</span> result</code></pre><p>i,j整体移动一遍就能得到结果，算法的时间复杂度是O(n)，最坏的情况是2*n。</p><p>我们重新审视一下这个双指针形成的滑动窗口，避免了重复的比较和判断，是处理数组和字符串问题的有效优化方法。LeetCode中给出的解决策略中这样定义滑动窗口：</p><blockquote><p>A sliding window is an abstract concept commonly used in array/string problems. A window is a range of elements in the array/string which usually defined by the start and end indices, i.e. [i, j)[i,j) (left-closed, right-open). A sliding window is a window “slides” its two boundaries to the certain direction. For example, if we slide [i, j)[i,j) to the right by 11 element, then it becomes [i+1, j+1)[i+1,j+1) (left-closed, right-open).</p></blockquote><p>再另一个经典问题快速排序中，我们同样可以使用滑动窗口的思想来进行一趟partition。</p><pre><code class="hljs java">partition(A,p,r)x=A[r]i=p-<span class="hljs-number">1</span><span class="hljs-keyword">for</span> j=p to r-<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> A[j]&lt;=x        i++        exchange A[i] with A[j]exchange A[i+<span class="hljs-number">1</span>] with A[r]retur i+<span class="hljs-number">1</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回文字符串问题分析</title>
    <link href="/2020/07/22/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/22/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>回文字符串，是指正读和倒读的结果一样的字符串，从结构上来看，两侧的字符呈中心对称。在汉语中，有很多有趣的回文诗词，回文对联熟语，比如“响水池中池水响，黄金谷里谷金黄”、“雾锁山头山锁雾，天连水尾水连天”等。根据其结构特征，我们很容易设计出一个判断字符串是否回文的算法：</p><pre><code class="hljs Java">isPalindromic(s)<span class="hljs-keyword">boolean</span> flag=<span class="hljs-keyword">true</span><span class="hljs-keyword">char</span>[] chars=s.toCharArray()<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span> to (chars.length-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> chars[i]!=chars[chars.length-<span class="hljs-number">1</span>-i]        flag=<span class="hljs-keyword">false</span>        <span class="hljs-keyword">break</span><span class="hljs-keyword">return</span> flag</code></pre><p>现在我们看一道leetcode中关于取一个字符串中最长的回文字的问题：</p><blockquote><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p></blockquote><p>首先最简单的方法，暴力穷举所有的子串，然后分别利用上述的方法进行判断即可。遍历+判断，穷举法总的时间复杂度为O(n^3).</p><pre><code class="hljs java">bruteForceForPalindromic(S)String result<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span> to s.length()-<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> j=i+<span class="hljs-number">1</span> to s.length()-<span class="hljs-number">1</span>        substring=s.substring(i,j)        <span class="hljs-keyword">if</span>(isPalindromic(substring) and substring.length()&lt;result.length())            result=substring</code></pre><p>很显然，上述暴力算法在运行效率上是极低的。主要原因是其存在着大量重复的判断，比如当substring(i,j)不是回文串时，我们可以确定substring(i-1,j+1)一定不是回文串，不用进行判断即可。由此我们考虑构造一个从中心节点双向探测的方法来获取最长的回文子串，即判断每一个中心节点可以构成的回文的最长串。现在的主要问题是，一共有多少个这样的中心节点呢？答案是2*n-1个，这是考虑了奇数回文和偶数回文的两种不同情况，如下图所示。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 以每一个点为中心点，向两边探测的方法判断回文</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> s</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getLongestPalindromic1</span><span class="hljs-params">(String s)</span> </span>&#123;        String result = <span class="hljs-string">""</span>;        String sub = <span class="hljs-string">""</span>;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-comment">//以此以每一个字符作为回文的中心节点centercode</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-comment">//奇数回文探测</span>            j = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (j &lt;= i &amp;&amp; i + j &lt; n &amp;&amp; chars[i - j] == chars[i + j]) &#123;                sub = s.substring(i - j, i + j + <span class="hljs-number">1</span>);                j++;            &#125;            result = result.length() &lt; sub.length() ? sub : result;            <span class="hljs-comment">//偶数回文探测</span>            j = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (j &lt;= i &amp;&amp; i + j + <span class="hljs-number">1</span> &lt; n &amp;&amp; chars[i - j] == chars[i + j + <span class="hljs-number">1</span>]) &#123;                sub = s.substring(i - j, i + j + <span class="hljs-number">2</span>);                j++;            &#125;            result = result.length() &lt; sub.length() ? sub : result;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre><p>现在我们接着回文串的子结构性质进行探讨，并考虑用动态规划的方法进行解决。</p><p>首先我们使用一个布尔类型的二维数组dptable[n][n]来表征第i个字符到底j个字符构成的子串是否回文，构成则值为true，否则为false。考虑到对于回文子串substring(i+1,j-1)当且仅当s[i]==[j]时，可以得到substring(i,j)是回文的。现在可以根据这样的性质去构造递推关系：</p><p>最后我们考虑动态规划的基础值的情况：</p><p>对于当个字符来说，其本身认为是回文的，则可以得到dptable[i][i]=true;</p><p>对于相邻的两个字符来说，如果两个字符是相等的，则认为其是回文的，否则不构成回文，所以dptable[i][i+1]=s[i]==s[i+1]。</p><p>综合上述的讨论，算法的时间复杂度为O(n^2)。Java实现如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 动态规划的方法求解最长回文子串</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> s</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getLongestPalindromicDP</span><span class="hljs-params">(String s)</span> </span>&#123;        String result = <span class="hljs-string">""</span>;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span> n = chars.length;        <span class="hljs-keyword">boolean</span>[][] dptable = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];        <span class="hljs-comment">//初始化动态规划数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                dptable[i][j] = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">//设置规划的base值</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            dptable[i][i] = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (chars[i] == chars[i + <span class="hljs-number">1</span>]) &#123;                dptable[i][i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-comment">//规划计算</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j - <span class="hljs-number">1</span>; i++) &#123;                dptable[i][j] = dptable[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (chars[i] == chars[j]);            &#125;        &#125;        <span class="hljs-comment">//取得最长的回文串</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (dptable[i][j] == <span class="hljs-keyword">true</span>) &#123;                    result = result.length() &lt;= j - i ? s.substring(i, j + <span class="hljs-number">1</span>) : result;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划算法Dynamic Programming</title>
    <link href="/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95Dynamic%20Programming/"/>
    <url>/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95Dynamic%20Programming/</url>
    
    <content type="html"><![CDATA[<p>动态规划与分治法相似，都是通过组合子问题的解来求解原问题。不同的是，分治法将问题划分为互不相交的子问题，递归的求解子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治法会做许多不必要的工作，他会反复求解那些公共子子问题。而动态规划只会对子子问题求解一次，将其保存在一个表格中，从而避免每次求解时都重新计算。现在我们来逐步的优化一个经典的问题——最长公共子序列，从中分析动态规划的思想方法。</p><h2 id="0-问题描述："><a href="#0-问题描述：" class="headerlink" title="0.问题描述："></a>0.问题描述：</h2><p>最长公共子序列问题（longest-common-subsequence problem）给定两个序列X=&lt;x1,x2,x3,…xm&gt;和Y=&lt;y1,y2,y3…yn&gt;，求X和Y的长度最长的公共子序列。</p><h2 id="1-暴力搜索方法："><a href="#1-暴力搜索方法：" class="headerlink" title="1.暴力搜索方法："></a>1.暴力搜索方法：</h2><p>我们把问题分割成两个部分：遍历和判断。首先遍历X的所有的子序列，然后依次进行判断是否为Y的子序列，并比较得出其中最长的一个。</p><p>对于判断，可以从左向右扫描一遍即可实现，复杂度为O(n)：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断sub是否为a的子序列</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> a</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sub</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] sub)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; sub.length) &#123;            <span class="hljs-keyword">if</span> (sub[j] == a[i]) &#123;                i++;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                i++;            &#125;        &#125;        <span class="hljs-keyword">if</span> (j &lt; sub.length)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><p>对于遍历，一个具有m个字符的序列，一共有2^m个子序列。然后逐一进行判断比较，这个算法的时间复杂度为O(2^m）*O(n).</p><p>我们可以借助深度优先搜索的思想进行子序列的遍历：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 暴力穷举的方法取最长公共子序列</span><span class="hljs-comment">    * 遍历一个字符串的所有的子序列，共有2^n种结果</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bruteforceForLCS</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars1, <span class="hljs-keyword">char</span>[] chars, String res, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">"k不能小于0"</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == chars.length) &#123;            <span class="hljs-keyword">if</span> (!res.isEmpty() &amp;&amp; isSubsequence(chars1, res.toCharArray()) &amp;&amp; longest.length() &lt; res.length()) &#123;                longest = res;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1</span>; i++) &#123;                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                    bruteforceForLCS(chars1, chars, res, k + <span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    bruteforceForLCS(chars1, chars, res + chars[k], k + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;</code></pre><h2 id="2-基于最优子结构性质的改进"><a href="#2-基于最优子结构性质的改进" class="headerlink" title="2.基于最优子结构性质的改进"></a>2.基于最优子结构性质的改进</h2><p>基本上，任何问题都是可以使用暴力搜索的方式去解决的，但可怕的是，当问题的规模达到一定的程度以后，即使使用最快的计算机，它也需要若干年甚至是若干世纪以后才能给出我们答案。人生苦短，暴力不值得。</p><p>通过对公共子序列形成规律的深入分析，我们发现这样的性质：</p><p>X=&lt;x1,x2,…xm&gt; ，Y=&lt;y1,y2,…yn&gt;，令Z=&lt;z1,z2,…zk&gt;位X和Y的任意最长公共子序列，则有：</p><p>如果Xm=Yn，那么Zk=Xm=Yn且Zk-1是Xm-1和Yn-1的一个最长公共子序列；<br>如果Xm！=Yn，那么Zk！=Xm意味着Z是Xm-1和Y的一个最长公共子序列；<br>如果Xm！=Yn，那么Zk！=Yn意味着Z是Xm和Yn-1的一个最长公共子序列；<br>所以，我们用这个规律来建立一个描述最长公共子序列长度的递归公式：</p><p>有了这个递归公式，我们就可以写出一个指数时间的算法来进行递归计算了：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 直接根据递归公式进行求解最长公共子序列</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpForLCS</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, Stack&lt;Character&gt; stack, <span class="hljs-keyword">boolean</span>[] aflag)</span> </span>&#123;        count++;        System.out.println(<span class="hljs-string">"递归程序正在执行i="</span> + i + <span class="hljs-string">",j="</span> + j);        <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span> || j == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;                <span class="hljs-keyword">if</span> (!aflag[i]) &#123;                    stack.push(a[i]);                    aflag[i] = <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-keyword">return</span> dpForLCS(a, b, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, stack, aflag) + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> Math.max(dpForLCS(a, b, i - <span class="hljs-number">1</span>, j, stack, aflag), dpForLCS(a, b, i, j - <span class="hljs-number">1</span>, stack, aflag));            &#125;        &#125;    &#125;</code></pre><h2 id="3-基于缓存思想的动态规划算法"><a href="#3-基于缓存思想的动态规划算法" class="headerlink" title="3.基于缓存思想的动态规划算法"></a>3.基于缓存思想的动态规划算法</h2><p>可以看出上面直接根据递归公式进行求解的方法会有很多的重复计算，比如为了求X和Y的一个LCS，我们可能需要求X和Yn-1的一个LCS以及Xm-1和Y的一个LCS，这几个问题都会包含Xm-1和Yn-1的LCS这个子问题，对于这种情况，我们将它描述为具有重叠子问题性质。解决的思路是借助缓存的思想，将已经计算出的子问题存储在一个表格里以避免重复进行计算。一般的，可以有如下的递归和迭代两种实现方式。</p><h3 id="3-1自顶向下的递归法（top-down-with-memoization）"><a href="#3-1自顶向下的递归法（top-down-with-memoization）" class="headerlink" title="3.1自顶向下的递归法（top-down with memoization）"></a>3.1自顶向下的递归法（top-down with memoization）</h3><p>此方法依然按照自然的递归形式编写函数，但函数中会保存每个字问题的解（通常保存在一个数组或者散列表中）。当需要一个子问题的解时，函数会首先检查是否保存过此解。如果是，直接返回保存的值，从而节省了计算时间。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 自顶向下法(递归形式的动态规划)</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpForLCSDown</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span>[][] length)</span> </span>&#123;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;                length[i][j] = (length[i][j] == -<span class="hljs-number">1</span> ? (dpForLCSDown(a, b, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, length) + <span class="hljs-number">1</span>) : length[i][j]);                <span class="hljs-keyword">return</span> length[i][j];            &#125; <span class="hljs-keyword">else</span> &#123;                length[i - <span class="hljs-number">1</span>][j] = length[i - <span class="hljs-number">1</span>][j] == -<span class="hljs-number">1</span> ? dpForLCSDown(a, b, i - <span class="hljs-number">1</span>, j, length) : length[i - <span class="hljs-number">1</span>][j];                length[i][j - <span class="hljs-number">1</span>] = length[i][j - <span class="hljs-number">1</span>] == -<span class="hljs-number">1</span> ? dpForLCSDown(a, b, i, j - <span class="hljs-number">1</span>, length) : length[i][j - <span class="hljs-number">1</span>];                <span class="hljs-keyword">return</span> Math.max(length[i - <span class="hljs-number">1</span>][j], length[i][j - <span class="hljs-number">1</span>]);            &#125;        &#125;    &#125;</code></pre><h3 id="3-2自底向上的迭代法（bottom-up-method）"><a href="#3-2自底向上的迭代法（bottom-up-method）" class="headerlink" title="3.2自底向上的迭代法（bottom-up method）"></a>3.2自底向上的迭代法（bottom-up method）</h3><p>把子问题按照规模进行排序，按照由小至大的顺序进行求解。当解决某个子问题时，它所依赖的更小的子问题都已经求解完毕，结果已经保存，每个子问题都只需求解一次。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 自底向上法(迭代形式的动态规划)</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpForLCSUp</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] b)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] length = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length][b.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;            length[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.length; j++) &#123;            length[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; b.length; j++) &#123;                <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;                    length[i][j] = length[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    length[i][j] = Math.max(length[i - <span class="hljs-number">1</span>][j], length[i][j - <span class="hljs-number">1</span>]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> length[a.length - <span class="hljs-number">1</span>][b.length - <span class="hljs-number">1</span>];    &#125;</code></pre><p>上述两种方法具有相同的渐进运行时间，但是由于没有频繁的递归函数调用的开销，自底向上方法的时间复杂度函数通常具有更小的系数。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>从上面的讨论过程中，我么可以看到适用动态规划算法求解的最优化问题应该具有两个要素：最优子结构性质和子问题重叠。首先，最优子结构性质可是使我们避免暴力遍历所有的子序列；其次，子问题重叠性质可以使我们借助缓存思想，避免对相同的子问题进行重复求解，从而达到比传统分治法更优的性能。最后，我们提炼出设计一个动态规划算法的步骤：</p><p>刻画一个最优解的结构特征；<br>递归的定义最优解的值；<br>计算最优解的值，通常采用自顶向上的方法；<br>利用计算出的信息构造一个最优解；<br>参考文献：<br>[1]Thomas H.Cormen Charles E.Leiserson.Introduction To Algorithms(Third Edition)[M].China Machine Press,2013</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存思想在算法设计中的应用</title>
    <link href="/2020/07/22/%E7%BC%93%E5%AD%98%E6%80%9D%E6%83%B3%E5%9C%A8%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/07/22/%E7%BC%93%E5%AD%98%E6%80%9D%E6%83%B3%E5%9C%A8%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1. 问题引入"></a>1. 问题引入</h2><p>我们先看一下简单的斐波那契数列的递归算法。百度百科中对该问题是这样定义的：</p><blockquote><p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896" target="_blank" rel="noopener">黄金分割</a>数列、因<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%AE%B6/1210991" target="_blank" rel="noopener">数学家</a>列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“<a href="https://baike.baidu.com/item/%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97/6849441" target="_blank" rel="noopener">兔子数列</a>”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(3)=2,F(n)=F(n-1)+F(n-2)（n&gt;=4，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p></blockquote><p>直接根据递推关系式，我们可以设计常规的递归算法：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> n=<span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">if</span> n=<span class="hljs-number">2</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">2</span> <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>)+fibonacci(n-<span class="hljs-number">2</span>)</code></pre><p>在这个方法中包含了大量重复的计算，比如在计算fibonacci(n)时需要计算一次fibonacci(n-2)的值，在计算fibonacci(n-1)时仍然要计算一次fibonacci(n-2)的值，问题的规模和计算的次数呈现如下的关系：</p><table><thead><tr><th>问题规模</th><th>计算次数</th></tr></thead><tbody><tr><td>3</td><td>count(4)+count(5)</td></tr><tr><td>4</td><td>count(5)+count(6)</td></tr><tr><td>5</td><td>count(6)+count(7)</td></tr><tr><td>n-3</td><td>count(n-1)+count(n-2)=3</td></tr><tr><td>n-2</td><td>count(n-2)=2</td></tr><tr><td>n-1</td><td>count(n-1)=1</td></tr></tbody></table><p>可以发现问题规模n的计算次数形成了一种“倒序”排列的斐波那契额数列，解决问题的所需要的计算次数和原问题呈现出相同的规模，执行效率会特别的慢。</p><p>事实上，我们可以使用一个数组缓存下已经计算的子问题的值，当子问题被再次用到时，直接使用缓存的值即可，避免重新计算，从而提升效率。</p><pre><code class="hljs java">初始化数组 A[<span class="hljs-number">1</span>..n]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>...<span class="hljs-number">0</span>&#125;fibonacci(n,A)<span class="hljs-keyword">if</span> n=<span class="hljs-number">1</span> <span class="hljs-keyword">return</span> A[<span class="hljs-number">1</span>]<span class="hljs-keyword">if</span> n=<span class="hljs-number">2</span> <span class="hljs-keyword">return</span> A[<span class="hljs-number">2</span>]<span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">2</span>     A[n]=(A[n-<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>?fabonacci(n-<span class="hljs-number">1</span>):A[n-<span class="hljs-number">1</span>])+(A[n-<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>?fabonacci(n-<span class="hljs-number">2</span>):A[n-<span class="hljs-number">2</span>])    <span class="hljs-keyword">return</span> A[n]</code></pre><p> 借助数组做数据缓存中间结果值，可以大大提升算法的运行效率。当然，对于斐波那契数列本身还有很多更好的优化方法，比如使用迭代进行一趟循环，或者借助斐波那契的矩阵乘法定义进行优化等。我们这里只是用这个例子来说明缓存在算法优化中的应用。</p><h2 id="2-思想分析"><a href="#2-思想分析" class="headerlink" title="2. 思想分析"></a>2. 思想分析</h2><p>现在我们把关注点回到缓存思想上来。从对斐波那契数列的优化过程中可以看到，缓存是典型的以空间换取时间的策略。在计算机的设计与程序设计过程中，缓存是一种经常用到的思想。</p><ul><li>在池化技术中，比如数据库连接池，线程池等，为了避免大对象重复创建造成的资源浪费，将连接对象缓存进池里重复使用以提升效率。</li><li>在计算机的体系结构中，为了调节CPU和内存之间的速度差异，使用二级缓存的方式，根据8020原则，对经常使用到数据做缓存，从而提升系统的运行效率。</li><li>在分布式系统的设计中，将数据缓存到离用户最近的位置以解决大数据场景下热点数据的访问性能问题。</li><li>在数据库的访问上，为了避免对硬盘的重复查询，使用Redis、Ehcache和Memcached等开源工具对热点查询数据缓存到内存中。</li><li>在动态规划的算法中，我们依然可以看到缓存的策略，比如在求解最长公共子序列时，使用了一个二维数组来对子问题的最优解做缓存。<br>综上比较，缓存思想的应用可以分成两个方面：一是，在速度相差比较大的软件/硬件之间，用以协调二者的速度差异，提升整体的吞吐率，比如计算机系统中的高速缓冲存储器；二是，对计算资源消耗较大的中间结果做缓存，以避免重复计算，比如数据库连接池中对连接对象的缓存避免重复对对象的创建，以及上述我们在优化斐波那契数列时对子问题中间结果的缓存等。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
