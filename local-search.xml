<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2020/11/14/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/11/14/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="代理模式综述"><a href="#代理模式综述" class="headerlink" title="代理模式综述"></a>代理模式综述</h4><p>​        在客户端和真实的服务之间引入了一个中间层作为代理，在代理层以面向切面的方式拓展服务的功能，比如在调用服务的前后打印日志、跟踪审计等。同时遵循开闭原则（对拓展开放，对修改关闭），在不修改原有服务的前提下增加业务处理逻辑。</p><p>​        一般的，按照代理对象的生成方式，将代理模式分成两类，静态代理和动态代理。静态代理以硬编码的方式直接为被代理类编写代理类，以组合的方式拓展被代理类的功能。在服务较多而代理层逻辑相似的情况下，重复的工作量很大。动态代理很好的解决了这个问题，不直接编写代理类，而是抽象出代理层的业务逻辑作为代理层处理器，然后使用反射的方式动态的为被代理类创建代理对象。目前，在java应用的范畴内，有JDK借助Proxy的动态代理和CGLib对字节码织入横切逻辑的动态代理两种实现方式。其中前者需要被代理类实现一个接口，后后者则放开了这个限制，可以实现对任意的非final的类的非final方法进行代理。</p><h4 id="代理模式的简单示例"><a href="#代理模式的简单示例" class="headerlink" title="代理模式的简单示例"></a>代理模式的简单示例</h4><ol><li>首先有一个被代理的服务及其接口：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PlainInterface</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PlainInterface</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"这是正常的业务逻辑！"</span>);&#125;&#125;</code></pre><ol start="2"><li>其次，若使用静态代理，直接为其封装代理类即可：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticProxyObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PlainInterface</span> </span>&#123;<span class="hljs-keyword">private</span> PlainInterface delegate;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticProxyObject</span><span class="hljs-params">(PlainInterface delegate)</span> </span>&#123;<span class="hljs-keyword">this</span>.delegate = delegate;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"这是通过静态代理切入的前置逻辑"</span>);delegate.hello();System.out.println(<span class="hljs-string">"这是通过静态代理切入的后置逻辑"</span>);&#125;&#125;</code></pre><ol start="3"><li>再次，若使用基于JDK Proxy体系的动态代理，需要创建一个实现InvocationHandler接口的代理事件处理器：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<span class="hljs-keyword">private</span> PlainInterface plain;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DynamicProxyHandler</span><span class="hljs-params">(PlainInterface plain)</span> </span>&#123;<span class="hljs-keyword">this</span>.plain=plain;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Method var2, Object[] var3)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;System.out.println(<span class="hljs-string">"这是通过动态代理切入的前置逻辑"</span>);var2.invoke(plain, var3);System.out.println(<span class="hljs-string">"这是通过动态代理切入的后置逻辑"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</code></pre><ol start="4"><li>如果使用基于CGLib的动态代理，需要引入cglib的jar包，同时写实现了MethodInterceptor的代理过滤器：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CGLibProxyIntercepter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;System.out.println(<span class="hljs-string">"这是通过CGLib动态代理切入的前置逻辑"</span>);Object result = proxy.invokeSuper(obj, args);System.out.println(<span class="hljs-string">"这是通过CGLib动态代理切入的后置逻辑"</span>);<span class="hljs-keyword">return</span> result;&#125;&#125;</code></pre><ol start="5"><li>最后，再客户端中分别使用静态代理和动态代理：</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProxy</span><span class="hljs-params">()</span> </span>&#123;    PlainInterface plain = <span class="hljs-keyword">new</span> PlainObject();    <span class="hljs-comment">// 包装了原对象的代理处理对象</span>    DynamicProxyHandler proxyHandler = <span class="hljs-keyword">new</span> DynamicProxyHandler(plain);    <span class="hljs-comment">// 动态代理生成的代理对象</span>    PlainInterface proxy = (PlainInterface) Proxy.newProxyInstance(plain.getClass().getClassLoader(),                                         plain.getClass().getInterfaces(), proxyHandler);    proxy.hello();    <span class="hljs-comment">// 静态代理对象</span>    StaticProxyObject staticProxyObject=<span class="hljs-keyword">new</span> StaticProxyObject(plain);    staticProxyObject.hello();    <span class="hljs-comment">// 测试基于CGLib的动态代理</span>    Enhancer enhancer=<span class="hljs-keyword">new</span> Enhancer();    enhancer.setSuperclass(PlainObject<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    enhancer.setCallback(<span class="hljs-keyword">new</span> CGLibProxyIntercepter());    PlainInterface cglibProxyObject= (PlainInterface) enhancer.create();    cglibProxyObject.hello();&#125;</code></pre><h4 id="动态代理在开源框架中的典型应用"><a href="#动态代理在开源框架中的典型应用" class="headerlink" title="动态代理在开源框架中的典型应用"></a>动态代理在开源框架中的典型应用</h4><p>在myBatis中，查询方法定义在dao或者mapper接口中，具体的查询方法在xml文件中配置。使用动态代理的方式为定义的每一个mapper(dao)接口构建一个实际执行查询操作的代理对象MapperProxy。</p><p>其中，代理对象的使用工厂模式，由MapperProxyFactory类进行构建：</p><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;<span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> Class[] &#123; mapperInterface &#125;,mapperProxy);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> </span>&#123;<span class="hljs-keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);<span class="hljs-keyword">return</span> newInstance(mapperProxy);&#125;</code></pre><p>在实际执行dao接口或者mapper接口的数据库操作方法时，实际上是调用的MapperProxy代理对象的拦截方法：（MapperProxy实现了InvocationHandler接口）</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (Object<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">equals</span>(<span class="hljs-title">method</span>.<span class="hljs-title">getDeclaringClass</span>())) </span>&#123;            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.isDefault()) &#123;            <span class="hljs-keyword">if</span> (privateLookupInMethod == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(t);    &#125;    <span class="hljs-keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);    <span class="hljs-keyword">return</span> mapperMethod.execute(sqlSession, args);&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件系统与基本命令</title>
    <link href="/2020/08/13/Linxu%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/08/13/Linxu%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>与Windows使用驱动盘符不同，Linux使用叫做<strong>虚拟目录</strong>的单一的目录结构存储文件。</p><blockquote><p>The Windows file path tells you exactly which physical disk partition contains the file named test.doc. For example, if you saved test.doc on a flash drive, designated by the J drive, the fi le path would be J:\test.doc. This path indicates that the file is located at the root of the drive assigned the letter J.This is not the method used by Linux. Linux stores fi les within a single directory structure, called a virtual directory. The virtual directory contains fi le paths from all the storage devices installed on the computer, merged into a single directory structure. The Linux virtual directory structure contains a single base directory, called the root. Directories and fi les beneath the root directory are listed based on the directory path used to get to them, similar to the way Windows does it.</p></blockquote><h3 id="Linux系统的文件目录"><a href="#Linux系统的文件目录" class="headerlink" title="Linux系统的文件目录"></a>Linux系统的文件目录</h3><p>一般的，Linux的文件目录基于<a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">FHS</a>（Filesystem Hierarchy Standard）。当登录系统以后，从/home目录开始，可以使用cd命令切换文件目录。</p><table><thead><tr><th>Directory</th><th>Usage</th></tr></thead><tbody><tr><td>/</td><td>root of the virtual directory, where normally, no files are placed</td></tr><tr><td>/bin</td><td>binary directory, where many GNU user-level utilities are stored</td></tr><tr><td>/boot</td><td>boot directory, where boot files are stored</td></tr><tr><td>/dev</td><td>device directory, where Linux creates device nodes</td></tr><tr><td>/etc</td><td>system configuration files directory</td></tr><tr><td>/home</td><td>home directory, where Linux creates user directories</td></tr><tr><td>/lib</td><td>library directory, where system and application library files are stored</td></tr><tr><td>/media</td><td>media directory, a common place for mount points used for removable media</td></tr><tr><td>/mnt</td><td>mount directory, another common place for mount points used for</td></tr><tr><td>removable media</td><td></td></tr><tr><td>/opt</td><td>optional directory, often used to store third-party software packages</td></tr><tr><td>and data files</td><td></td></tr><tr><td>/proc</td><td>process directory, where current hardware and process information is stored</td></tr><tr><td>/root</td><td>root home directory</td></tr><tr><td>/sbin</td><td>system binary directory, where many GNU admin-level utilities are stored</td></tr><tr><td>/run</td><td>run directory, where runtime data is held during system operation</td></tr><tr><td>/srv</td><td>service directory, where local services store their files</td></tr><tr><td>/sys</td><td>system directory, where system hardware information files are stored</td></tr><tr><td>/tmp</td><td>temporary directory, where temporary work files can be created and destroyed</td></tr><tr><td>/usr</td><td>user binary directory, where the bulk of GNU user-level utilities and data files are</td></tr><tr><td>stored</td><td></td></tr><tr><td>/var</td><td>variable directory, for files that change frequently, such as log files</td></tr></tbody></table><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><p>在使用<strong>ls -l</strong>命令查询某个目录下的文件时，会展示出与文件访问权限相关的信息。其中第一位是文件类型位，其含义如下列表所示：</p><table><thead><tr><th>flag</th><th>meanning</th></tr></thead><tbody><tr><td>-</td><td>for files</td></tr><tr><td>d</td><td>for directories</td></tr><tr><td>l</td><td>for links</td></tr><tr><td>c</td><td>for character devices</td></tr><tr><td>b</td><td>for block devices</td></tr><tr><td>n</td><td>for network devices</td></tr></tbody></table><p>第二至九位是权限控制为，每三个一组，分别代表属主的权限，属组的权限和其他人员的权限。每个组内，三位字符分别是读权限r，写权限w和执行权限x，如果没有对应权限则置为-。具体的，八进制权限为：</p><table><thead><tr><th>permissions</th><th>Binary</th><th>Octal</th><th>Description</th></tr></thead><tbody><tr><td>—</td><td>000</td><td>0</td><td>No permissions</td></tr><tr><td>–x</td><td>001</td><td>1</td><td>Execute-only permission</td></tr><tr><td>-w-</td><td>010</td><td>2</td><td>Write-only permission</td></tr><tr><td>-wx</td><td>011</td><td>3</td><td>Write and execute permissions</td></tr><tr><td>r–</td><td>100</td><td>4</td><td>Read-only permission</td></tr><tr><td>r-x</td><td>101</td><td>5</td><td>Read and execute permissions</td></tr><tr><td>rw-</td><td>110</td><td>6</td><td>Read and write permissions</td></tr><tr><td>rwx</td><td>111</td><td>7</td><td>Read, write, and execute permissions</td></tr></tbody></table><h3 id="常用的操作文件的命令"><a href="#常用的操作文件的命令" class="headerlink" title="常用的操作文件的命令"></a>常用的操作文件的命令</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件导入的技术梳理</title>
    <link href="/2020/07/22/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A2%B3%E7%90%86/"/>
    <url>/2020/07/22/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="文件导入的基本思路"><a href="#文件导入的基本思路" class="headerlink" title="文件导入的基本思路"></a>文件导入的基本思路</h2><p>文件上传到服务器和其他向后台传递数据的方法是一致的，都是基于HTTP协议发送请求报文，区别仅在于发送的数据格式上。具体的，文件上传基于HTTP协议，使用POST方法提交页面form表单中的file元素。在提交的请求头中设置Content-Type为multipart/form-data,即设置form表单的enctype属性为该值。然后用表单的submit方法同步上传或者用ajax异步上传。文件导入在技术上涉及前端数据的发送和后台数据的接收两部分，后台的数据接收会因为不同的服务器实现方式和语言有不同的表现，本文集中分析前端数据发送部分，即基于form表单的file是如何传递到后端服务器中的。</p><h2 id="直接使用表单提交方法同步上传"><a href="#直接使用表单提交方法同步上传" class="headerlink" title="直接使用表单提交方法同步上传"></a>直接使用表单提交方法同步上传</h2><p>这是最典型的方法，直接submit提交到action属性所定义的服务器接收路径中。可以给submit添加监听事件处理器来执行一些数据校验的工作。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/api/upload"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"POST"</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>&gt;</span>        选择文件：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"uploadFile"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p>form可以通过四种方式进行提交：</p><table><thead><tr><th>method</th><th>enctype</th><th>note</th></tr></thead><tbody><tr><td>POST</td><td>application/x-www-form-urlencoded</td><td>default</td></tr><tr><td>POST</td><td>text/plain</td><td></td></tr><tr><td>POST</td><td>multipart/form-data</td><td>进行文件上传使用这个方法</td></tr><tr><td>GET</td><td>will be ignored</td><td></td></tr></tbody></table><h2 id="使用原生的XMLHttpRequest对象异步上传"><a href="#使用原生的XMLHttpRequest对象异步上传" class="headerlink" title="使用原生的XMLHttpRequest对象异步上传"></a>使用原生的XMLHttpRequest对象异步上传</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest API</a>中有关于该对象的ajax技术的详细介绍。</p><blockquote><p>XMLHttpRequest (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. XMLHttpRequest is used heavily in AJAX programming.</p></blockquote><p>可以借助这个对象，异步上传文件，避免在上传大文件时前台页面卡顿。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submitData</span>(<span class="hljs-params">oData</span>) </span>&#123;    <span class="hljs-comment">/* the AJAX request... */</span>    <span class="hljs-keyword">var</span> oAjaxReq = <span class="hljs-keyword">new</span> XMLHttpRequest();    oAjaxReq.submittedData = oData;    oAjaxReq.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.responseText);&#125;;    <span class="hljs-keyword">if</span> (oData.technique === <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">/* method is GET */</span>        oAjaxReq.open(<span class="hljs-string">"get"</span>, oData.receiver.replace(<span class="hljs-regexp">/(?:\?.*)?$/</span>,oData.segments.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">"?"</span> + oData.segments.join(<span class="hljs-string">"&amp;"</span>) : <span class="hljs-string">""</span>), <span class="hljs-literal">true</span>);        oAjaxReq.send(<span class="hljs-literal">null</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">/* method is POST */</span>        oAjaxReq.open(<span class="hljs-string">"post"</span>, oData.receiver, <span class="hljs-literal">true</span>);        <span class="hljs-keyword">if</span> (oData.technique === <span class="hljs-number">3</span>) &#123;            <span class="hljs-comment">/* enctype is multipart/form-data */</span>            <span class="hljs-keyword">var</span> sBoundary = <span class="hljs-string">"---------------------------"</span> + <span class="hljs-built_in">Date</span>.now().toString(<span class="hljs-number">16</span>);            oAjaxReq.setRequestHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"multipart\/form-data; boundary="</span> + sBoundary);            oAjaxReq.sendAsBinary(<span class="hljs-string">"--"</span> + sBoundary + <span class="hljs-string">"\r\n"</span> +            oData.segments.join(<span class="hljs-string">"--"</span> + sBoundary + <span class="hljs-string">"\r\n"</span>) + <span class="hljs-string">"--"</span> + sBoundary + <span class="hljs-string">"--\r\n"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">/* enctype is application/x-www-form-urlencoded or text/plain */</span>            oAjaxReq.setRequestHeader(<span class="hljs-string">"Content-Type"</span>, oData.contentType);            oAjaxReq.send(oData.segments.join(oData.technique === <span class="hljs-number">2</span> ? <span class="hljs-string">"\r\n"</span> : <span class="hljs-string">"&amp;"</span>));        &#125;    &#125;&#125;</code></pre><h2 id="使用FormData对象组织提交的参数"><a href="#使用FormData对象组织提交的参数" class="headerlink" title="使用FormData对象组织提交的参数"></a>使用FormData对象组织提交的参数</h2><blockquote><p>The FormData constructor lets you compile a set of key/value pairs to send using XMLHttpRequest. Its primary use is in sending form data, but can also be used independently from a form in order to transmit user keyed data. The transmitted data is in the same format the form’s submit() method uses to send data, if the form’s encoding type were set to “multipart/form-data”. FormData objects can be utilized in a number of ways with an XMLHttpRequest.</p></blockquote><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AJAXSubmit</span>(<span class="hljs-params">oFormElement</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!oFormElement.action) &#123; <span class="hljs-keyword">return</span>; &#125;    <span class="hljs-keyword">var</span> oReq = <span class="hljs-keyword">new</span> XMLHttpRequest();    oReq.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.responseText);&#125;;    <span class="hljs-keyword">if</span> (oFormElement.method.toLowerCase() === <span class="hljs-string">"post"</span>) &#123;        oReq.open(<span class="hljs-string">"post"</span>, oFormElement.action);        oReq.send(<span class="hljs-keyword">new</span> FormData(oFormElement));    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">var</span> oField, sFieldType, nFile, sSearch = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> nItem = <span class="hljs-number">0</span>; nItem &lt; oFormElement.elements.length; nItem++) &#123;            oField = oFormElement.elements[nItem];            <span class="hljs-keyword">if</span> (!oField.hasAttribute(<span class="hljs-string">"name"</span>)) &#123; <span class="hljs-keyword">continue</span>; &#125;            sFieldType = oField.nodeName.toUpperCase() === <span class="hljs-string">"INPUT"</span> ?                oField.getAttribute(<span class="hljs-string">"type"</span>).toUpperCase() : <span class="hljs-string">"TEXT"</span>;            <span class="hljs-keyword">if</span> (sFieldType === <span class="hljs-string">"FILE"</span>) &#123;                <span class="hljs-keyword">for</span> (nFile = <span class="hljs-number">0</span>; nFile &lt; oField.files.length;                    sSearch += <span class="hljs-string">"&amp;"</span> + <span class="hljs-built_in">escape</span>(oField.name) + <span class="hljs-string">"="</span> + <span class="hljs-built_in">escape</span>(oField.files[nFile++].name));            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sFieldType !== <span class="hljs-string">"RADIO"</span> &amp;&amp; sFieldType !== <span class="hljs-string">"CHECKBOX"</span>) || oField.checked) &#123;                sSearch += <span class="hljs-string">"&amp;"</span> + <span class="hljs-built_in">escape</span>(oField.name) + <span class="hljs-string">"="</span> + <span class="hljs-built_in">escape</span>(oField.value);            &#125;        &#125;        oReq.open(<span class="hljs-string">"get"</span>, oFormElement.action.replace(<span class="hljs-regexp">/(?:\?.*)?$/</span>, sSearch.replace(<span class="hljs-regexp">/^&amp;/</span>, <span class="hljs-string">"?"</span>)), <span class="hljs-literal">true</span>);        oReq.send(<span class="hljs-literal">null</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于双指针的滑动窗口方法在数组问题中的应用</title>
    <link href="/2020/07/22/%E5%9F%BA%E4%BA%8E%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%96%B9%E6%B3%95%E5%9C%A8%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/07/22/%E5%9F%BA%E4%BA%8E%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%96%B9%E6%B3%95%E5%9C%A8%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LeetCode中有道题：取一个字符串中不含重复字符的最长子串的长度。<br>原题是：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p><blockquote><p>Given a string, find the length of the longest substring without repeating characters.</p></blockquote><p> 最直接的想法是暴力法穷举所有的子串，取其中不包含重复字符的最长的一个。</p><pre><code class="hljs java">result=<span class="hljs-number">0</span><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to n-<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> j=i+<span class="hljs-number">1</span> to n        s=substring(i,j)        <span class="hljs-keyword">if</span>(s.allunique() and s.length&gt;result)            result=s.length<span class="hljs-keyword">return</span> result</code></pre><p>其中判断一个字符串是否包含不重复的字符，借助集合的数据结构，至少需要一趟比较。所以，暴力穷举的时间复杂度将达到</p><p>O(n^3)。当需要处理的字符创较长时，LeetCode平台将拒绝接受。</p><p>考虑对暴力方法进行优化：当substring(i,j)含有重复字符时，那么substring(i,k) k[i+1,n] 一定会包含重复字符，不用再进行判断即可，此时需要将头部指针i向后移动一个单位继续判断即可；若substring(i,j)不含有重复字符，则将尾部指针j向后移动一个单位继续判断。i和j之间则形成了一个滑动窗口。所以基于双指针i和j形成如下优化算法：</p><pre><code class="hljs java">i=<span class="hljs-number">0</span>j=<span class="hljs-number">1</span>result=<span class="hljs-number">0</span><span class="hljs-keyword">while</span>(i&lt;n and j&lt;n)    <span class="hljs-keyword">while</span>(j&lt;<span class="hljs-function">n and <span class="hljs-title">substring</span><span class="hljs-params">(i,j)</span>.<span class="hljs-title">contains</span><span class="hljs-params">(string.chatAt(j)</span>))</span><span class="hljs-function">        j++</span><span class="hljs-function">    result</span>=result&gt;j-i?result:j-i    i++<span class="hljs-keyword">return</span> result</code></pre><p>i,j整体移动一遍就能得到结果，算法的时间复杂度是O(n)，最坏的情况是2*n。</p><p>我们重新审视一下这个双指针形成的滑动窗口，避免了重复的比较和判断，是处理数组和字符串问题的有效优化方法。LeetCode中给出的解决策略中这样定义滑动窗口：</p><blockquote><p>A sliding window is an abstract concept commonly used in array/string problems. A window is a range of elements in the array/string which usually defined by the start and end indices, i.e. [i, j)[i,j) (left-closed, right-open). A sliding window is a window “slides” its two boundaries to the certain direction. For example, if we slide [i, j)[i,j) to the right by 11 element, then it becomes [i+1, j+1)[i+1,j+1) (left-closed, right-open).</p></blockquote><p>再另一个经典问题快速排序中，我们同样可以使用滑动窗口的思想来进行一趟partition。</p><pre><code class="hljs java">partition(A,p,r)x=A[r]i=p-<span class="hljs-number">1</span><span class="hljs-keyword">for</span> j=p to r-<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> A[j]&lt;=x        i++        exchange A[i] with A[j]exchange A[i+<span class="hljs-number">1</span>] with A[r]retur i+<span class="hljs-number">1</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回文字符串问题分析</title>
    <link href="/2020/07/22/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/22/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>回文字符串，是指正读和倒读的结果一样的字符串，从结构上来看，两侧的字符呈中心对称。在汉语中，有很多有趣的回文诗词，回文对联熟语，比如“响水池中池水响，黄金谷里谷金黄”、“雾锁山头山锁雾，天连水尾水连天”等。根据其结构特征，我们很容易设计出一个判断字符串是否回文的算法：</p><pre><code class="hljs Java">isPalindromic(s)<span class="hljs-keyword">boolean</span> flag=<span class="hljs-keyword">true</span><span class="hljs-keyword">char</span>[] chars=s.toCharArray()<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span> to (chars.length-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> chars[i]!=chars[chars.length-<span class="hljs-number">1</span>-i]        flag=<span class="hljs-keyword">false</span>        <span class="hljs-keyword">break</span><span class="hljs-keyword">return</span> flag</code></pre><p>现在我们看一道leetcode中关于取一个字符串中最长的回文字的问题：</p><blockquote><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p></blockquote><p>首先最简单的方法，暴力穷举所有的子串，然后分别利用上述的方法进行判断即可。遍历+判断，穷举法总的时间复杂度为O(n^3).</p><pre><code class="hljs java">bruteForceForPalindromic(S)String result<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span> to s.length()-<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> j=i+<span class="hljs-number">1</span> to s.length()-<span class="hljs-number">1</span>        substring=s.substring(i,j)        <span class="hljs-keyword">if</span>(isPalindromic(substring) and substring.length()&lt;result.length())            result=substring</code></pre><p>很显然，上述暴力算法在运行效率上是极低的。主要原因是其存在着大量重复的判断，比如当substring(i,j)不是回文串时，我们可以确定substring(i-1,j+1)一定不是回文串，不用进行判断即可。由此我们考虑构造一个从中心节点双向探测的方法来获取最长的回文子串，即判断每一个中心节点可以构成的回文的最长串。现在的主要问题是，一共有多少个这样的中心节点呢？答案是2*n-1个，这是考虑了奇数回文和偶数回文的两种不同情况，如下图所示。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 以每一个点为中心点，向两边探测的方法判断回文</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> s</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getLongestPalindromic1</span><span class="hljs-params">(String s)</span> </span>&#123;        String result = <span class="hljs-string">""</span>;        String sub = <span class="hljs-string">""</span>;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-comment">//以此以每一个字符作为回文的中心节点centercode</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-comment">//奇数回文探测</span>            j = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (j &lt;= i &amp;&amp; i + j &lt; n &amp;&amp; chars[i - j] == chars[i + j]) &#123;                sub = s.substring(i - j, i + j + <span class="hljs-number">1</span>);                j++;            &#125;            result = result.length() &lt; sub.length() ? sub : result;            <span class="hljs-comment">//偶数回文探测</span>            j = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (j &lt;= i &amp;&amp; i + j + <span class="hljs-number">1</span> &lt; n &amp;&amp; chars[i - j] == chars[i + j + <span class="hljs-number">1</span>]) &#123;                sub = s.substring(i - j, i + j + <span class="hljs-number">2</span>);                j++;            &#125;            result = result.length() &lt; sub.length() ? sub : result;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre><p>现在我们接着回文串的子结构性质进行探讨，并考虑用动态规划的方法进行解决。</p><p>首先我们使用一个布尔类型的二维数组dptable[n][n]来表征第i个字符到底j个字符构成的子串是否回文，构成则值为true，否则为false。考虑到对于回文子串substring(i+1,j-1)当且仅当s[i]==[j]时，可以得到substring(i,j)是回文的。现在可以根据这样的性质去构造递推关系：</p><p>最后我们考虑动态规划的基础值的情况：</p><p>对于当个字符来说，其本身认为是回文的，则可以得到dptable[i][i]=true;</p><p>对于相邻的两个字符来说，如果两个字符是相等的，则认为其是回文的，否则不构成回文，所以dptable[i][i+1]=s[i]==s[i+1]。</p><p>综合上述的讨论，算法的时间复杂度为O(n^2)。Java实现如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 动态规划的方法求解最长回文子串</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> s</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getLongestPalindromicDP</span><span class="hljs-params">(String s)</span> </span>&#123;        String result = <span class="hljs-string">""</span>;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span> n = chars.length;        <span class="hljs-keyword">boolean</span>[][] dptable = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];        <span class="hljs-comment">//初始化动态规划数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                dptable[i][j] = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">//设置规划的base值</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            dptable[i][i] = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (chars[i] == chars[i + <span class="hljs-number">1</span>]) &#123;                dptable[i][i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-comment">//规划计算</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j - <span class="hljs-number">1</span>; i++) &#123;                dptable[i][j] = dptable[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (chars[i] == chars[j]);            &#125;        &#125;        <span class="hljs-comment">//取得最长的回文串</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (dptable[i][j] == <span class="hljs-keyword">true</span>) &#123;                    result = result.length() &lt;= j - i ? s.substring(i, j + <span class="hljs-number">1</span>) : result;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划算法Dynamic Programming</title>
    <link href="/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95Dynamic%20Programming/"/>
    <url>/2020/07/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95Dynamic%20Programming/</url>
    
    <content type="html"><![CDATA[<p>动态规划与分治法相似，都是通过组合子问题的解来求解原问题。不同的是，分治法将问题划分为互不相交的子问题，递归的求解子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治法会做许多不必要的工作，他会反复求解那些公共子子问题。而动态规划只会对子子问题求解一次，将其保存在一个表格中，从而避免每次求解时都重新计算。现在我们来逐步的优化一个经典的问题——最长公共子序列，从中分析动态规划的思想方法。</p><h2 id="0-问题描述："><a href="#0-问题描述：" class="headerlink" title="0.问题描述："></a>0.问题描述：</h2><p>最长公共子序列问题（longest-common-subsequence problem）给定两个序列X=&lt;x1,x2,x3,…xm&gt;和Y=&lt;y1,y2,y3…yn&gt;，求X和Y的长度最长的公共子序列。</p><h2 id="1-暴力搜索方法："><a href="#1-暴力搜索方法：" class="headerlink" title="1.暴力搜索方法："></a>1.暴力搜索方法：</h2><p>我们把问题分割成两个部分：遍历和判断。首先遍历X的所有的子序列，然后依次进行判断是否为Y的子序列，并比较得出其中最长的一个。</p><p>对于判断，可以从左向右扫描一遍即可实现，复杂度为O(n)：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断sub是否为a的子序列</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> a</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sub</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] sub)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; sub.length) &#123;            <span class="hljs-keyword">if</span> (sub[j] == a[i]) &#123;                i++;                j++;            &#125; <span class="hljs-keyword">else</span> &#123;                i++;            &#125;        &#125;        <span class="hljs-keyword">if</span> (j &lt; sub.length)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><p>对于遍历，一个具有m个字符的序列，一共有2^m个子序列。然后逐一进行判断比较，这个算法的时间复杂度为O(2^m）*O(n).</p><p>我们可以借助深度优先搜索的思想进行子序列的遍历：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 暴力穷举的方法取最长公共子序列</span><span class="hljs-comment">    * 遍历一个字符串的所有的子序列，共有2^n种结果</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bruteforceForLCS</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars1, <span class="hljs-keyword">char</span>[] chars, String res, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">"k不能小于0"</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == chars.length) &#123;            <span class="hljs-keyword">if</span> (!res.isEmpty() &amp;&amp; isSubsequence(chars1, res.toCharArray()) &amp;&amp; longest.length() &lt; res.length()) &#123;                longest = res;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1</span>; i++) &#123;                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                    bruteforceForLCS(chars1, chars, res, k + <span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    bruteforceForLCS(chars1, chars, res + chars[k], k + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;</code></pre><h2 id="2-基于最优子结构性质的改进"><a href="#2-基于最优子结构性质的改进" class="headerlink" title="2.基于最优子结构性质的改进"></a>2.基于最优子结构性质的改进</h2><p>基本上，任何问题都是可以使用暴力搜索的方式去解决的，但可怕的是，当问题的规模达到一定的程度以后，即使使用最快的计算机，它也需要若干年甚至是若干世纪以后才能给出我们答案。人生苦短，暴力不值得。</p><p>通过对公共子序列形成规律的深入分析，我们发现这样的性质：</p><p>X=&lt;x1,x2,…xm&gt; ，Y=&lt;y1,y2,…yn&gt;，令Z=&lt;z1,z2,…zk&gt;位X和Y的任意最长公共子序列，则有：</p><p>如果Xm=Yn，那么Zk=Xm=Yn且Zk-1是Xm-1和Yn-1的一个最长公共子序列；<br>如果Xm！=Yn，那么Zk！=Xm意味着Z是Xm-1和Y的一个最长公共子序列；<br>如果Xm！=Yn，那么Zk！=Yn意味着Z是Xm和Yn-1的一个最长公共子序列；<br>所以，我们用这个规律来建立一个描述最长公共子序列长度的递归公式：</p><p>有了这个递归公式，我们就可以写出一个指数时间的算法来进行递归计算了：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 直接根据递归公式进行求解最长公共子序列</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpForLCS</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, Stack&lt;Character&gt; stack, <span class="hljs-keyword">boolean</span>[] aflag)</span> </span>&#123;        count++;        System.out.println(<span class="hljs-string">"递归程序正在执行i="</span> + i + <span class="hljs-string">",j="</span> + j);        <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span> || j == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;                <span class="hljs-keyword">if</span> (!aflag[i]) &#123;                    stack.push(a[i]);                    aflag[i] = <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-keyword">return</span> dpForLCS(a, b, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, stack, aflag) + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> Math.max(dpForLCS(a, b, i - <span class="hljs-number">1</span>, j, stack, aflag), dpForLCS(a, b, i, j - <span class="hljs-number">1</span>, stack, aflag));            &#125;        &#125;    &#125;</code></pre><h2 id="3-基于缓存思想的动态规划算法"><a href="#3-基于缓存思想的动态规划算法" class="headerlink" title="3.基于缓存思想的动态规划算法"></a>3.基于缓存思想的动态规划算法</h2><p>可以看出上面直接根据递归公式进行求解的方法会有很多的重复计算，比如为了求X和Y的一个LCS，我们可能需要求X和Yn-1的一个LCS以及Xm-1和Y的一个LCS，这几个问题都会包含Xm-1和Yn-1的LCS这个子问题，对于这种情况，我们将它描述为具有重叠子问题性质。解决的思路是借助缓存的思想，将已经计算出的子问题存储在一个表格里以避免重复进行计算。一般的，可以有如下的递归和迭代两种实现方式。</p><h3 id="3-1自顶向下的递归法（top-down-with-memoization）"><a href="#3-1自顶向下的递归法（top-down-with-memoization）" class="headerlink" title="3.1自顶向下的递归法（top-down with memoization）"></a>3.1自顶向下的递归法（top-down with memoization）</h3><p>此方法依然按照自然的递归形式编写函数，但函数中会保存每个字问题的解（通常保存在一个数组或者散列表中）。当需要一个子问题的解时，函数会首先检查是否保存过此解。如果是，直接返回保存的值，从而节省了计算时间。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 自顶向下法(递归形式的动态规划)</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpForLCSDown</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span>[][] length)</span> </span>&#123;        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;                length[i][j] = (length[i][j] == -<span class="hljs-number">1</span> ? (dpForLCSDown(a, b, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, length) + <span class="hljs-number">1</span>) : length[i][j]);                <span class="hljs-keyword">return</span> length[i][j];            &#125; <span class="hljs-keyword">else</span> &#123;                length[i - <span class="hljs-number">1</span>][j] = length[i - <span class="hljs-number">1</span>][j] == -<span class="hljs-number">1</span> ? dpForLCSDown(a, b, i - <span class="hljs-number">1</span>, j, length) : length[i - <span class="hljs-number">1</span>][j];                length[i][j - <span class="hljs-number">1</span>] = length[i][j - <span class="hljs-number">1</span>] == -<span class="hljs-number">1</span> ? dpForLCSDown(a, b, i, j - <span class="hljs-number">1</span>, length) : length[i][j - <span class="hljs-number">1</span>];                <span class="hljs-keyword">return</span> Math.max(length[i - <span class="hljs-number">1</span>][j], length[i][j - <span class="hljs-number">1</span>]);            &#125;        &#125;    &#125;</code></pre><h3 id="3-2自底向上的迭代法（bottom-up-method）"><a href="#3-2自底向上的迭代法（bottom-up-method）" class="headerlink" title="3.2自底向上的迭代法（bottom-up method）"></a>3.2自底向上的迭代法（bottom-up method）</h3><p>把子问题按照规模进行排序，按照由小至大的顺序进行求解。当解决某个子问题时，它所依赖的更小的子问题都已经求解完毕，结果已经保存，每个子问题都只需求解一次。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 自底向上法(迭代形式的动态规划)</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dpForLCSUp</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">char</span>[] b)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] length = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length][b.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;            length[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.length; j++) &#123;            length[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; b.length; j++) &#123;                <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123;                    length[i][j] = length[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    length[i][j] = Math.max(length[i - <span class="hljs-number">1</span>][j], length[i][j - <span class="hljs-number">1</span>]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> length[a.length - <span class="hljs-number">1</span>][b.length - <span class="hljs-number">1</span>];    &#125;</code></pre><p>上述两种方法具有相同的渐进运行时间，但是由于没有频繁的递归函数调用的开销，自底向上方法的时间复杂度函数通常具有更小的系数。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>从上面的讨论过程中，我么可以看到适用动态规划算法求解的最优化问题应该具有两个要素：最优子结构性质和子问题重叠。首先，最优子结构性质可是使我们避免暴力遍历所有的子序列；其次，子问题重叠性质可以使我们借助缓存思想，避免对相同的子问题进行重复求解，从而达到比传统分治法更优的性能。最后，我们提炼出设计一个动态规划算法的步骤：</p><p>刻画一个最优解的结构特征；<br>递归的定义最优解的值；<br>计算最优解的值，通常采用自顶向上的方法；<br>利用计算出的信息构造一个最优解；<br>参考文献：<br>[1]Thomas H.Cormen Charles E.Leiserson.Introduction To Algorithms(Third Edition)[M].China Machine Press,2013</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存思想在算法设计中的应用</title>
    <link href="/2020/07/22/%E7%BC%93%E5%AD%98%E6%80%9D%E6%83%B3%E5%9C%A8%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2020/07/22/%E7%BC%93%E5%AD%98%E6%80%9D%E6%83%B3%E5%9C%A8%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1. 问题引入"></a>1. 问题引入</h2><p>我们先看一下简单的斐波那契数列的递归算法。百度百科中对该问题是这样定义的：</p><blockquote><p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896" target="_blank" rel="noopener">黄金分割</a>数列、因<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%AE%B6/1210991" target="_blank" rel="noopener">数学家</a>列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“<a href="https://baike.baidu.com/item/%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97/6849441" target="_blank" rel="noopener">兔子数列</a>”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(3)=2,F(n)=F(n-1)+F(n-2)（n&gt;=4，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p></blockquote><p>直接根据递推关系式，我们可以设计常规的递归算法：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> n=<span class="hljs-number">1</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">if</span> n=<span class="hljs-number">2</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">2</span> <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>)+fibonacci(n-<span class="hljs-number">2</span>)</code></pre><p>在这个方法中包含了大量重复的计算，比如在计算fibonacci(n)时需要计算一次fibonacci(n-2)的值，在计算fibonacci(n-1)时仍然要计算一次fibonacci(n-2)的值，问题的规模和计算的次数呈现如下的关系：</p><table><thead><tr><th>问题规模</th><th>计算次数</th></tr></thead><tbody><tr><td>3</td><td>count(4)+count(5)</td></tr><tr><td>4</td><td>count(5)+count(6)</td></tr><tr><td>5</td><td>count(6)+count(7)</td></tr><tr><td>n-3</td><td>count(n-1)+count(n-2)=3</td></tr><tr><td>n-2</td><td>count(n-2)=2</td></tr><tr><td>n-1</td><td>count(n-1)=1</td></tr></tbody></table><p>可以发现问题规模n的计算次数形成了一种“倒序”排列的斐波那契额数列，解决问题的所需要的计算次数和原问题呈现出相同的规模，执行效率会特别的慢。</p><p>事实上，我们可以使用一个数组缓存下已经计算的子问题的值，当子问题被再次用到时，直接使用缓存的值即可，避免重新计算，从而提升效率。</p><pre><code class="hljs java">初始化数组 A[<span class="hljs-number">1</span>..n]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>...<span class="hljs-number">0</span>&#125;fibonacci(n,A)<span class="hljs-keyword">if</span> n=<span class="hljs-number">1</span> <span class="hljs-keyword">return</span> A[<span class="hljs-number">1</span>]<span class="hljs-keyword">if</span> n=<span class="hljs-number">2</span> <span class="hljs-keyword">return</span> A[<span class="hljs-number">2</span>]<span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">2</span>     A[n]=(A[n-<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>?fabonacci(n-<span class="hljs-number">1</span>):A[n-<span class="hljs-number">1</span>])+(A[n-<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>?fabonacci(n-<span class="hljs-number">2</span>):A[n-<span class="hljs-number">2</span>])    <span class="hljs-keyword">return</span> A[n]</code></pre><p> 借助数组做数据缓存中间结果值，可以大大提升算法的运行效率。当然，对于斐波那契数列本身还有很多更好的优化方法，比如使用迭代进行一趟循环，或者借助斐波那契的矩阵乘法定义进行优化等。我们这里只是用这个例子来说明缓存在算法优化中的应用。</p><h2 id="2-思想分析"><a href="#2-思想分析" class="headerlink" title="2. 思想分析"></a>2. 思想分析</h2><p>现在我们把关注点回到缓存思想上来。从对斐波那契数列的优化过程中可以看到，缓存是典型的以空间换取时间的策略。在计算机的设计与程序设计过程中，缓存是一种经常用到的思想。</p><ul><li>在池化技术中，比如数据库连接池，线程池等，为了避免大对象重复创建造成的资源浪费，将连接对象缓存进池里重复使用以提升效率。</li><li>在计算机的体系结构中，为了调节CPU和内存之间的速度差异，使用二级缓存的方式，根据8020原则，对经常使用到数据做缓存，从而提升系统的运行效率。</li><li>在分布式系统的设计中，将数据缓存到离用户最近的位置以解决大数据场景下热点数据的访问性能问题。</li><li>在数据库的访问上，为了避免对硬盘的重复查询，使用Redis、Ehcache和Memcached等开源工具对热点查询数据缓存到内存中。</li><li>在动态规划的算法中，我们依然可以看到缓存的策略，比如在求解最长公共子序列时，使用了一个二维数组来对子问题的最优解做缓存。<br>综上比较，缓存思想的应用可以分成两个方面：一是，在速度相差比较大的软件/硬件之间，用以协调二者的速度差异，提升整体的吞吐率，比如计算机系统中的高速缓冲存储器；二是，对计算资源消耗较大的中间结果做缓存，以避免重复计算，比如数据库连接池中对连接对象的缓存避免重复对对象的创建，以及上述我们在优化斐波那契数列时对子问题中间结果的缓存等。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
